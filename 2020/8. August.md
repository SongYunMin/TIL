## 2020.08.08
### Web Server와 WAS의 차이점
## Static Pages

- Web Server는 파일 경로 이름을 받아 경로와 일치하는 File Contents를 반환한다.
- 항상 동일한 페이지를 반환한다.
- Ex) Image, html, css, javascript파일과 같이 컴퓨터에 저장되어 있는 파일들

## Dynamic Pages

- 인자의 내용에 맞게 동적인 contents를 반환한다.
- 즉, 웹 서버에 의해서 실행되는 프로그램을 통해서 만들어진 결과물 
*Servlet: WAS위에서 돌아가는 Java Program
- 개발자는 Servlet에 doGet()을 구현한다.

# Web Server와 WAS의 차이

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0dcda02c-5f4e-4661-9638-1c4602869396/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0dcda02c-5f4e-4661-9638-1c4602869396/Untitled.png)

## Web Server

- Web Server의 개념
    - 소프트웨어와 하드웨어로 구분된다.
    - 1) 하드웨어
        - Web 서버가 설치되어 있는 컴퓨터
    - 2) 소프트웨어
        - 웹 브라우저 클라이언트로부터 HTTP 요청을 받아 **정적인 컨텐츠 (.html.jpeg.css 등)** 를 제공하는 컴퓨터 프로그램
- Web Server의 기능
    - **HTTP 프로토콜을 기반으로 하여 클라이언트(웹  브라우저 또는 웹 크롤러)의 요청을 서비스 하는 기능**을 담당한다.
    - 요청에 따라 아래의 두 가지 기능 중 적절하게 선택하여 수행한다.
    - 기능 1)
        - 정적인 컨텐츠 제공
        - WAS를 거치지 않고 바로 자원을 제공한다.
    - 기능 2)
        - 동적인 컨텐츠 제공을 위한 요청 전달
        - 클라이언트의 요청(Request)을 WAS에 보내고, WAS가 처리한 결과를 클라이언트에게 전달(응답, Reponse)한다.
        - 클라이언트는 일반적으로 웹 브라우저를 의미한다.
    - Web Server의 예
        - Apache Server, Nginx, IIS(Windows전용 Web 서버) 등

## WAS(Web Application Server)

- WAS의 개념
    - DB 조회나 다양한 로직 처리를 요구하는 **동적인 컨텐츠**를 제공하기 위해 만들어진 Application Server
    - HTTP를 통해 컴퓨터나 장치에 애플리케이션을 수행해주는 미들웨어(소프트웨어 엔진)이다.
    - **"웹 컨테이너 (Web Container)"혹은 "서블릿 컨테이너(Servlet Container)"**라고도 불린다.
        - Container란 JSP, Servlet을 실행시킬 수있는 소프트웨어를 말한다.
        - 즉, WAS는 JSP, Servlet 구동 환경을 제공한다.
- WAS의 역할
    - **WAS = Web Server + Web Container**
    - Web Server 기능들을 구조적으로 분리하여 처리하고자하는 목적으로 제시되었다.
        - 분산 트랜잭션, 보안, 메시징 ,쓰레드 처리 등의 기능을 처리하는 분산 환경에서 사용된다.
        - 주로 DB서버와 같이 수행된다.
    - 현재는 WAS가 가지고 있는 Web Server도 정적인 컨텐츠를 처리하는 데 있어서 성능상 큰 차이가 없다.
- WAS의 주요 기능
    - 프로그램 실행 환경과 DB접속 기능 제공
    - 여러 개의 트랜잭션(논리적인 작업 단위)관리 기능
    - 업무를 처리하는 비지니스 로직 수행
- WAS의 예
    - Ex) Tomcat JBoss,Jeus,Web Sphere 등

# Web Server와 WAS를 구분하는 이유

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d7200cb9-89e5-479b-94d0-058b8d19fa67/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d7200cb9-89e5-479b-94d0-058b8d19fa67/Untitled.png)

## Web Server가 필요한 이유?

- 클라이언트(웹 브라우저)에 이미지 파일(정적 컨텐츠)을 보내는 과정을 생각해보자.
    - 이미지 파일과 같은 정적인 파일들은 웹 문서(HTML 문서)가 클라이언트로 보내질 때 함께가는 것이 아니다.
    - 클라이언트는 HTML문서를 먼저 받고 그에 맞게 필요한 이미지 파일들을 다시 서버로 요청하면 그때서야 이미지 파일을 받아온다.
    - Web Server를 통해 정적인 파일들을 Application Server까지 가지 않고 앞단에서 빠르게 보내줄 수 있다.
- 따라서 Web Server에서는 정적 컨텐츠만 처리하도록 기능을 분배하여 서버의 부담을 줄일 수 있다.

## WAS가 필요한 이유?

- 웹 페이지는 정적 컨텐츠와 동적 컨텐츠가 모두 존재한다.
    - 사용자의 요청에 맞게 적절한 동적 컨텐츠를 만들어서 제공해야 한다.
    - 이때, Web Server만을 이용한다면 사용자가 원하는 요청에 대한 결과값을 모두 미리 만들어 놓고 서비스를 해야한다.
    - 하지만 이렇게 수행하기에는 자원이 절대적으로 부족하다.
- 따라서 WAS를 통해 요청에 맞는 데이터를 DB에서 가져와서 비즈니스 로직에 맞게 그때 그때 결과를 만들어서 제공함으로써 자원을 효율적으로 사용할 수 있다.

## 그렇다면 WAS가 Web Server의 기능도 모두 수행하면 되지 않을까?

1. **기능을 분리하여 서버 부하 방지**
    - WAS는 DB 조회나 다양한 로직을 처리하느라 바쁘기 때문에 단순한 정적 컨텐츠는 Web Server에서 빠르게 클라이언트에 제공하는 것이 좋다.
    - WAS는 기본적으로 동적 컨텐츠를 제공하기 위해 존재하는 서버이다.
    - 만약 정적 컨텐츠 요청까지 WAS까지 처리한다면 정적 데이터 처리로 인해 부하가 커지게 되고, 동적 컨텐츠의 처리가 지연됨에 따라 수행 속도가 느려진다.
    - 즉, 이로 인해 페이지 노출 시간이 늘어나게 될 것이다.
2. **물리적으로 분리하여 보안 강화**
    - SSL에 대한 암복호화 처리에 Wev Server를 사용
3. **여러 대의 WAS를 연결 가능**
    - Load Balancing을 위해서 Web Server를 사용
    - fail over(장애 극복), fail back 처리에 유리
    - 특히 대용량 웹 어플리케이션의 경우(여러 개의 서버 사용) Web Server와 WAS를 분리 하여 무중단 운영을 위한 장애 극복에 쉽게 대응할 수 있다.
    - 예를 들어, 앞 단의 Web Server에서 오류가 발생한 WAS를 이용하지 못하도록 한 후 WAS를 재 시작함으로써 사용자는 오류를 느끼지 못하고 이용할 수 있다.
4. **여러 웹 어플리케이션 서비스 가능**
    - 예를 들어, 하나의 서버에서 PHP Aplication과 Java Application을 함께 사용하는 경우
5. **기타**
    - 접근 허용 IP관리, 2대 이상의 서버에서 세션 관리 등도 Web Server에서 처리하면 효율적이다.
- 즉, 자원 이용의 효율성 및 장애 극복, 배포 및 유지보수의 편의성을 위해 Web Server와 WAS를 분리한다.
- **WEB Server를 WAS앞에 두고 필요한 WAS들을 Web Server에 플러그인 형태로 설정하면 더욱 효율적인 분산 처리가 가능하다.**

## 2020.08.09
## 소프트웨어 생명 주기 (Software Life Cycle)

소프트웨어 생명 주기는 소프트웨어 개발 방법론의 바탕, 소프트웨어를 개발하기 위해 정의하고 운용, 유지보수 등의 과정을 각 단계별로 나눈 것

- 소프트웨어 생명 주기는 소프트웨어 개발 단계와 각 단계별 주요 활동, 그리고 활동 결과에 대한 산출물로 표현 함, **소프트웨어 수명 주기라고도 함**
- 생명 주기를 표현하는 형태를 **생명 주기 모형이라고 함**
- 일반적으로 사용되는 소프트웨어 생명 주기 모형에는 **폭포수 모형, 프로토타입 모형, 나선형 모형, 애자일 모형 등이 있음**

## 폭포수 모형(Waterfall Model)

폭포에서 한번 떨어진 물은 거슬러 올라갈 수 없듯이 소프트웨어 개발도 이전 단계로 돌아갈 수 없다는 전제하에 각 단계를 확실히 매듭짓고 다음 단계를 진행하는 개발 방법론

- 고전적 생명 주기 모형이라고도 함
- 개발 과정의 한 단계가 끝나야만 당므 단계로 넘어갈 수 있는 순차적 모형
- 제품의 일부가 될 메뉴얼을 작성해야 함
- 각 단계가 끝난 후에는 다음 단계를 수행하기 위한 결과물이 명확하게 산출되어야 함
- 두개 이상의 과정이 병행하여 수행되지 않아야 함

> Ex) 타당성 검토 → 계획 → 요구분석 → 설계 → 구현 → 시험 → 유지보수

## 프로토 타입 모형(Prototype Model, 원형 모형)

사용자의 요구사항을 정확히 파악하기 위해 실제 개발될 소프트웨어에 대한 견본품을 만들어 최종 결과물을 예측하는 모형

- 시제품은 사용자와 시스템 사이 인터페이스에 중점을 둠
- 시스템의 일부 혹은 시스템의 모형을 만드는 과정, 추후 구현 단계에서 사용될 골격 코드
- **개발이 완료된 시점에서 오류가 발견되는 폭포수 모형의 단점을 보완하기 위한 모형**

## 나선형 모형(Spiral Model, 점진적 모형)

나선형 모형은 보헴이 제안, 폭포수, 프로토 모형의 장점에 위험 분석 기능을 추가한 모형

- 나선을 따라 돌듯이 여러 번의 소프트웨어 개발 과정을 거쳐 점진적으로 완벽한 최종 소프트웨어를 개발하는 것, **점진적 모형이라고도 함**
- **점진적으로 개발 과정이 반복되므로 누락되거나 추가된 요구사항을 첨가할 수 있고, 정밀하며 유지보수 과정이 필요없음**

## 애자일 모형(Agile Model)

'민첩한', '기민함' 이라는 의미, 고객 요구사항 변화에 유연하게 대응할 수 있도록 일정한 주기를 반복하면서 개발과정 진행

- 어느 특정 개발방법론이 아니라 좋은 것을 빠르고 낭비없게 만들기 위해 **고객과의 소통에 초점을 맞춘 방법론을 통칭함**
- 애자일 모형은 스프린트(Sprint)또는 이터레이션 (Iteration)이라고 불리는 짧은 개발주기를 반복, 주기마다 결과물에 대한 고객의 평가와 요구를 적극 수용함
- 애자일 모형을 기반으로 하는 소프트웨어 개발 모형에는 **스크럼, XP, 칸반(Kanban), Lean, 크리스탈, ASD, FDD DSDM, DAD 등이 있다.**

## 2020.08.16
### 데이터베이스 보안 - 접근통제
### 임의 접근통제 (Discretionary Access Control)
- 신원에 따라 권한 부여
- 주체가 통제권한을 지정 및 제어한다
- DAC는 객체를 생성한 사용자가 생성 객체의 모든 권한을 부여 받고, 부여된 권한을 다른 사용자에게 허가 할 수도 있다.
- EX) GRANT, REVOKE
### 강제 접근통제
- 주체와 객체의 등급을 비교, 권한 부여 함
- 제 3자가 접근통제 권한을 지정함
- 데이터베이스 객체별로 보안 등급을 부여할 수 있고, 사용자별로 인가 등급을 부여할 수 있다.
- 주체는 자신보다 보안 등급이 높은 객체에 대해 읽기, 수정, 등록이 모두 불가능
- 보안 등급이 같은 객체에 대해서는 읽기, 수정, 등록이 가능하고, 보안 등급이 낮은 객체는 읽기가 가능하다.

## 2020.08.17
### MVC Pattern (Model-View_Controller Pattern)
모델-뷰-컨트롤러 패턴은 서브시스템을 3개의 부분으로 구조화하는 패턴이며, 각 부분의 역할은 다음과 같다.
- 모델(Model) : 서브시스템의 핵심 기능과 데이터를 보관
- 뷰(view) : 사용자에게 정보를 표시한다.
- 컨트롤러(Controller) : 사용자로부터 받은 입력을 처리한다.
#### 특징
- 모델 - 뷰 - 컨트롤러 패턴의 각 부분은 별도의 컴포넌트로 분리되어 있으므로 서로 영향을 받지 않고 개발 작업을 수행할 수 있다.
- 모델 - 뷰 - 컨트롤러 패턴에서는 여러 개의 뷰를 만들 수 있으므로 한 개의 모델에 대해 여러 개의 뷰를 필요로 하는 대화형 애플리케이션에 적합하다.

## 2020.08.19
### Pipe-Filter Pattern
데이터 스트림 절차의 각 단계를 필터 컴포넌트로 캡슐화하여 파이프를 통해 데이터를 전송하는 패턴
#### 특징
- 필터 컴포넌트는 재사용성이 좋고, 추가가 쉬워 확장이 용이하다.
- 필터 컴포넌트들을 재배치하여 다양한 파이프라인을 구축하는 것이 가능하다
- 파이프-필터 패턴은 데이터변환, 버퍼링, 동기화 등에 주로 사용 됨
- 대표적으로 UNIX의 쉘이 있다.

## 레이어 패턴(Layers Pattern)

레이어 패턴은 시스템을 계층으로 구분하여 구성하는 고전적인 방법

- 레이어 패턴은 각각 서브시스템들이 계층 구조를 이루며, **상위 계층은 하위 계층에 대한 서비스 제공자가 되고 하위 계층은 상위 계층의 클라이언트가 된다.**
- 서로 마주보는 **두 계층 사이에서만 상호작용**이 이루어진다. = 변경 작업이 용이
- **특정 계층만을 교체해 시스템을 개선**하는 것이 가능하다.

## 클라이언트-서버 패턴(Client-Server Pattern)

**하나의 서버 컴포넌트**와 **다수의 클라이언트** 컴포넌트로 구성되는 패턴이다.

- 사용자는 클라이언트와만 의사소통을 한다.
- 사용자가 클라이언트를 통해 서버에 요청하고, **클라이언트가 응답을 받아 사용자에게 제공**하는방식으로 서비스를 제공
- 서로 동기화 되는 경우를 제외하고는 **서로 독립적**

## 2020.08.20
### Design Pattern
디자인 패턴은 각 모듈의 세분화된 역할이나 모듈들 간의 인터페이스와 같은 코드를 작성하는 수준의 세부적인 구현 방안을 설계할 때 참고할 수 있는 전형적인 해결 방식 또는 예제를 의미한다
- 디자인 패턴은 한 패턴에 변형을 가하거나, 특정 요구사항을 반영하면 유사한 형태의 다른 패턴으로 변화되는 특징이 있다.
- GoF의 디자인 패턴은 유형에 따라 생성 패턴 5개, 구조 패턴 7개, 행위 패턴 11개 총 23개의 패턴으로 구성된다.

## 2020.10.09
